package testutils

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
	"time"

	"lsp-gateway/internal/testing/pooling"
)

// MultiProjectRepositoryManager provides an interface for managing multi-project workspaces
type MultiProjectRepositoryManager interface {
	SetupMultiProjectWorkspace(languages []string) (string, error)
	GetSubProjects() []*SubProjectInfo
	GetSubProjectPath(projectType string) (string, error)
	ValidateMultiProject() error
	Cleanup() error
	GetWorkspaceDir() string
}

// SubProjectInfo holds information about a sub-project within the multi-project workspace
type SubProjectInfo struct {
	Language     string
	ProjectPath  string
	RootMarkers  []string
	TestFiles    []string
	LSPConfig    map[string]string
}

// MultiProjectConfig provides configuration for the multi-project manager
type MultiProjectConfig struct {
	TargetDir        string
	CloneTimeout     time.Duration
	EnableLogging    bool
	ForceClean       bool
	PreserveGitDir   bool
	EnablePooling    bool
	PoolConfig       *pooling.PoolConfig
	FallbackOnPoolingFailure bool
}

// ConcreteMultiProjectManager implements MultiProjectRepositoryManager
type ConcreteMultiProjectManager struct {
	config         MultiProjectConfig
	workspaceDir   string
	subProjects    []*SubProjectInfo
	repoManagers   map[string]*GenericRepoManager
	mu             sync.RWMutex
	lastError      error
	maxConcurrency int
	setupMetrics   map[string]time.Duration
	metricsMu      sync.Mutex
	
	// Pooling integration
	serverPoolManager *pooling.ServerPoolManager
	poolingEnabled    bool
	poolingMetrics    map[string]*PooledClientMetrics
	poolingValidator  *PoolingIntegrationValidator
}

// NewMultiProjectRepositoryManager creates a new multi-project repository manager
func NewMultiProjectRepositoryManager(config MultiProjectConfig) MultiProjectRepositoryManager {
	if config.CloneTimeout == 0 {
		config.CloneTimeout = 120 * time.Second
	}

	if config.TargetDir == "" {
		uniqueID := fmt.Sprintf("%d", time.Now().UnixNano())
		config.TargetDir = filepath.Join("/tmp", "lspg-multi-project-e2e-tests", uniqueID)
	}

	maxConcurrency := runtime.NumCPU()
	if maxConcurrency > 4 {
		maxConcurrency = 4 // Limit to 4 concurrent operations to avoid overwhelming system
	}

	mpm := &ConcreteMultiProjectManager{
		config:         config,
		workspaceDir:   config.TargetDir,
		subProjects:    []*SubProjectInfo{},
		repoManagers:   make(map[string]*GenericRepoManager),
		maxConcurrency: maxConcurrency,
		setupMetrics:   make(map[string]time.Duration),
		poolingEnabled: config.EnablePooling,
		poolingMetrics: make(map[string]*PooledClientMetrics),
	}

	// Initialize pooling support if enabled
	if config.EnablePooling {
		mpm.initializePoolingSupport()
	}

	return mpm
}

// SetupMultiProjectWorkspace creates a workspace with multiple sub-projects of different languages
func (mpm *ConcreteMultiProjectManager) SetupMultiProjectWorkspace(languages []string) (string, error) {
	startTime := time.Now()
	mpm.log("Setting up multi-project workspace with languages: %v (max concurrency: %d)", languages, mpm.maxConcurrency)

	// Prepare workspace with write lock
	mpm.mu.Lock()
	if err := mpm.prepareWorkspace(); err != nil {
		mpm.lastError = fmt.Errorf("workspace preparation failed: %w", err)
		mpm.mu.Unlock()
		return "", mpm.lastError
	}
	mpm.mu.Unlock()

	// Setup projects in parallel
	setupErrors := mpm.setupProjectsParallel(languages)
	
	// Check for errors
	if len(setupErrors) > 0 {
		mpm.mu.Lock()
		mpm.lastError = fmt.Errorf("failed to setup projects: %v", setupErrors)
		mpm.mu.Unlock()
		return "", mpm.lastError
	}

	totalTime := time.Since(startTime)
	mpm.log("Multi-project workspace setup completed in %v: %s", totalTime, mpm.workspaceDir)
	mpm.logPerformanceMetrics()
	
	return mpm.workspaceDir, nil
}

// setupProjectsParallel sets up multiple projects concurrently
func (mpm *ConcreteMultiProjectManager) setupProjectsParallel(languages []string) []error {
	if len(languages) == 0 {
		return nil
	}

	// Create semaphore to limit concurrent goroutines
	semaphore := make(chan struct{}, mpm.maxConcurrency)
	
	// Create channels for results and errors
	type setupResult struct {
		language    string
		subProject  *SubProjectInfo
		repoManager *GenericRepoManager
		err         error
		duration    time.Duration
	}
	
	resultChan := make(chan setupResult, len(languages))
	var wg sync.WaitGroup

	// Start goroutines for each language
	for _, language := range languages {
		wg.Add(1)
		go func(lang string) {
			defer wg.Done()
			
			// Acquire semaphore
			semaphore <- struct{}{}
			defer func() { <-semaphore }()
			
			startTime := time.Now()
			mpm.log("Starting parallel setup for %s", lang)
			
			subProject, repoManager, err := mpm.setupSubProjectParallel(lang)
			duration := time.Since(startTime)
			
			resultChan <- setupResult{
				language:    lang,
				subProject:  subProject,
				repoManager: repoManager,
				err:         err,
				duration:    duration,
			}
			
			if err != nil {
				mpm.log("Failed to setup %s in %v: %v", lang, duration, err)
			} else {
				mpm.log("Successfully setup %s in %v", lang, duration)
			}
		}(language)
	}

	// Wait for all goroutines to complete
	go func() {
		wg.Wait()
		close(resultChan)
	}()

	// Collect results
	var errors []error
	results := make([]setupResult, 0, len(languages))
	
	for result := range resultChan {
		results = append(results, result)
		
		// Store metrics
		mpm.metricsMu.Lock()
		mpm.setupMetrics[result.language] = result.duration
		mpm.metricsMu.Unlock()
		
		if result.err != nil {
			errors = append(errors, fmt.Errorf("%s: %w", result.language, result.err))
		}
	}

	// Store successful results with write lock
	if len(errors) == 0 {
		mpm.mu.Lock()
		for _, result := range results {
			if result.err == nil {
				mpm.subProjects = append(mpm.subProjects, result.subProject)
				mpm.repoManagers[result.language] = result.repoManager
			}
		}
		mpm.mu.Unlock()
	}

	return errors
}

// GetSubProjects returns all sub-projects in the workspace
func (mpm *ConcreteMultiProjectManager) GetSubProjects() []*SubProjectInfo {
	mpm.mu.RLock()
	defer mpm.mu.RUnlock()

	// Return a copy to prevent external modification
	result := make([]*SubProjectInfo, len(mpm.subProjects))
	copy(result, mpm.subProjects)
	return result
}

// GetSubProjectPath returns the path for a specific project type
func (mpm *ConcreteMultiProjectManager) GetSubProjectPath(projectType string) (string, error) {
	mpm.mu.RLock()
	defer mpm.mu.RUnlock()

	for _, subProject := range mpm.subProjects {
		if subProject.Language == projectType {
			return subProject.ProjectPath, nil
		}
	}

	return "", fmt.Errorf("project type %s not found in workspace", projectType)
}

// ValidateMultiProject validates all sub-projects in the workspace
func (mpm *ConcreteMultiProjectManager) ValidateMultiProject() error {
	mpm.mu.RLock()
	defer mpm.mu.RUnlock()

	if len(mpm.subProjects) == 0 {
		return fmt.Errorf("no sub-projects found in workspace")
	}

	// Validate each sub-project
	for _, subProject := range mpm.subProjects {
		repoManager, exists := mpm.repoManagers[subProject.Language]
		if !exists {
			return fmt.Errorf("repository manager not found for language: %s", subProject.Language)
		}

		if err := repoManager.ValidateRepository(); err != nil {
			return fmt.Errorf("validation failed for %s project: %w", subProject.Language, err)
		}
	}

	return nil
}

// Cleanup removes the workspace directory and performs cleanup operations
func (mpm *ConcreteMultiProjectManager) Cleanup() error {
	mpm.mu.Lock()
	defer mpm.mu.Unlock()

	mpm.log("Starting cleanup of multi-project workspace: %s", mpm.workspaceDir)

	// Cleanup individual repository managers
	for language, repoManager := range mpm.repoManagers {
		if err := repoManager.Cleanup(); err != nil {
			mpm.log("Warning: cleanup failed for %s project: %v", language, err)
		}
	}

	// Clear internal state
	mpm.subProjects = []*SubProjectInfo{}
	mpm.repoManagers = make(map[string]*GenericRepoManager)
	
	// Clear metrics
	mpm.metricsMu.Lock()
	mpm.setupMetrics = make(map[string]time.Duration)
	mpm.metricsMu.Unlock()

	if mpm.workspaceDir == "" {
		return nil
	}

	if _, err := os.Stat(mpm.workspaceDir); os.IsNotExist(err) {
		return nil
	}

	err := os.RemoveAll(mpm.workspaceDir)
	if err != nil {
		mpm.log("Cleanup failed: %v", err)
		return fmt.Errorf("failed to remove workspace directory: %w", err)
	}

	mpm.log("Cleanup completed successfully")
	return nil
}

// GetWorkspaceDir returns the workspace directory path
func (mpm *ConcreteMultiProjectManager) GetWorkspaceDir() string {
	mpm.mu.RLock()
	defer mpm.mu.RUnlock()
	return mpm.workspaceDir
}

// Private helper methods

func (mpm *ConcreteMultiProjectManager) log(format string, args ...interface{}) {
	if mpm.config.EnableLogging {
		fmt.Printf("[MultiProjectManager] %s\n", fmt.Sprintf(format, args...))
	}
}

func (mpm *ConcreteMultiProjectManager) prepareWorkspace() error {
	if mpm.config.ForceClean {
		if err := os.RemoveAll(mpm.workspaceDir); err != nil && !os.IsNotExist(err) {
			mpm.log("Warning: failed to clean existing workspace: %v", err)
		}
	}

	return os.MkdirAll(mpm.workspaceDir, 0755)
}

func (mpm *ConcreteMultiProjectManager) setupSubProject(language string) error {
	mpm.log("Setting up %s sub-project", language)

	// Get language configuration
	langConfig, err := mpm.getLanguageConfig(language)
	if err != nil {
		return fmt.Errorf("failed to get language config for %s: %w", language, err)
	}

	// Create sub-project directory
	subProjectDir := mpm.getSubProjectName(language)
	subProjectPath := filepath.Join(mpm.workspaceDir, subProjectDir)

	// Create repository manager configuration
	repoConfig := GenericRepoConfig{
		LanguageConfig: langConfig,
		TargetDir:      subProjectPath,
		CloneTimeout:   mpm.config.CloneTimeout,
		EnableLogging:  mpm.config.EnableLogging,
		ForceClean:     mpm.config.ForceClean,
		PreserveGitDir: mpm.config.PreserveGitDir,
	}

	// Extract commit hash from language config if available
	if commitHash, exists := langConfig.CustomVariables["commit_hash"]; exists {
		repoConfig.CommitHash = commitHash
	}

	// Create and setup repository manager
	repoManager := NewGenericRepoManager(repoConfig)
	actualPath, err := repoManager.SetupRepository()
	if err != nil {
		return fmt.Errorf("failed to setup repository for %s: %w", language, err)
	}

	// Get test files
	testFiles, err := repoManager.GetTestFiles()
	if err != nil {
		mpm.log("Warning: failed to get test files for %s: %v", language, err)
		testFiles = []string{} // Continue with empty test files
	}

	// Create SubProjectInfo
	subProjectInfo := &SubProjectInfo{
		Language:    language,
		ProjectPath: actualPath,
		RootMarkers: langConfig.RootMarkers,
		TestFiles:   testFiles,
		LSPConfig:   langConfig.CustomVariables,
	}

	// Store the sub-project and repository manager
	mpm.subProjects = append(mpm.subProjects, subProjectInfo)
	mpm.repoManagers[language] = repoManager

	mpm.log("Successfully set up %s sub-project at: %s", language, actualPath)
	return nil
}

// setupSubProjectParallel is a thread-safe version of setupSubProject for parallel execution
func (mpm *ConcreteMultiProjectManager) setupSubProjectParallel(language string) (*SubProjectInfo, *GenericRepoManager, error) {
	mpm.log("Setting up %s sub-project (parallel)", language)

	// Get language configuration
	langConfig, err := mpm.getLanguageConfig(language)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to get language config for %s: %w", language, err)
	}

	// Create sub-project directory
	subProjectDir := mpm.getSubProjectName(language)
	subProjectPath := filepath.Join(mpm.workspaceDir, subProjectDir)

	// Create repository manager configuration
	repoConfig := GenericRepoConfig{
		LanguageConfig: langConfig,
		TargetDir:      subProjectPath,
		CloneTimeout:   mpm.config.CloneTimeout,
		EnableLogging:  mpm.config.EnableLogging,
		ForceClean:     mpm.config.ForceClean,
		PreserveGitDir: mpm.config.PreserveGitDir,
	}

	// Extract commit hash from language config if available
	if commitHash, exists := langConfig.CustomVariables["commit_hash"]; exists {
		repoConfig.CommitHash = commitHash
	}

	// Create and setup repository manager
	repoManager := NewGenericRepoManager(repoConfig)
	actualPath, err := repoManager.SetupRepository()
	if err != nil {
		return nil, nil, fmt.Errorf("failed to setup repository for %s: %w", language, err)
	}

	// Get test files
	testFiles, err := repoManager.GetTestFiles()
	if err != nil {
		mpm.log("Warning: failed to get test files for %s: %v", language, err)
		testFiles = []string{} // Continue with empty test files
	}

	// Create SubProjectInfo
	subProjectInfo := &SubProjectInfo{
		Language:    language,
		ProjectPath: actualPath,
		RootMarkers: langConfig.RootMarkers,
		TestFiles:   testFiles,
		LSPConfig:   langConfig.CustomVariables,
	}

	mpm.log("Successfully set up %s sub-project at: %s (parallel)", language, actualPath)
	return subProjectInfo, repoManager, nil
}

// logPerformanceMetrics logs performance metrics for each language setup
func (mpm *ConcreteMultiProjectManager) logPerformanceMetrics() {
	if !mpm.config.EnableLogging {
		return
	}

	mpm.metricsMu.Lock()
	defer mpm.metricsMu.Unlock()

	if len(mpm.setupMetrics) == 0 {
		return
	}

	mpm.log("=== Multi-Project Setup Performance Metrics ===")
	
	var totalTime time.Duration
	for language, duration := range mpm.setupMetrics {
		mpm.log("  %s: %v", language, duration)
		totalTime += duration
	}
	
	// Calculate parallel efficiency
	avgSequentialTime := totalTime / time.Duration(len(mpm.setupMetrics))
	mpm.log("  Total sequential time would be: %v", totalTime)
	mpm.log("  Average per language: %v", avgSequentialTime)
	mpm.log("  Languages processed: %d", len(mpm.setupMetrics))
	mpm.log("  Max concurrency used: %d", mpm.maxConcurrency)
	mpm.log("===============================================")
}

func (mpm *ConcreteMultiProjectManager) getLanguageConfig(language string) (LanguageConfig, error) {
	switch strings.ToLower(language) {
	case "go", "golang":
		return GetGoLanguageConfig(), nil
	case "python", "py":
		return GetPythonLanguageConfig(), nil
	case "javascript", "js":
		return GetJavaScriptLanguageConfig(), nil
	case "typescript", "ts":
		return GetTypeScriptLanguageConfig(), nil
	case "java":
		return GetJavaLanguageConfig(), nil
	case "rust", "rs":
		return GetRustLanguageConfig(), nil
	default:
		return LanguageConfig{}, fmt.Errorf("unsupported language: %s", language)
	}
}

func (mpm *ConcreteMultiProjectManager) getSubProjectName(language string) string {
	switch strings.ToLower(language) {
	case "go", "golang":
		return "go-project"
	case "python", "py":
		return "python-project"
	case "javascript", "js":
		return "javascript-project"
	case "typescript", "ts":
		return "typescript-project"
	case "java":
		return "java-project"
	case "rust", "rs":
		return "rust-project"
	default:
		return fmt.Sprintf("%s-project", language)
	}
}